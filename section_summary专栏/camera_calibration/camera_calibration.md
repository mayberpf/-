# Camera calibration
因为最近是搞到了一个工业相机，是海康的。那就很方便进行一系列的实践，本篇文章主要是在这个过程中对相机标定的一个总结。

## 原理
有关标定原理，我想这是一件比较复杂的事情。接下来我们来说说。首先我想我们应该清楚相机标定的目的和一些基本的概念。
1、相机标定的目的：真实世界是三维的，图片是二维的；实际我们就是需要三维世界和二维图片可以经过一个函数互相转换。因此相机标定的目的就是找到一个数学模型，求出这个模型的参数，这样就能够近似逼近这个三维到二维的过程，同时求出成像的反过程，也就是从二维到三维的过程。(这是我的个人理解)。后面这句话是我从csdn中找到别人的话语：
```
#相机标定的目标是我们找一个合适的数学模型，求出这个模型的参数，这样我们能够近似这个三维到二维的过程，使这个三维到二维的过程的函数找到反函数。
```
我感觉这说的好文言文。ok，到这里我们就清楚，这个逼近过程就是相机标定的过程。那么一个人举着标定板在相机前面转来转去是干啥呢？请听下文分解。
2、相机标定的参数主要包括：相机内参(焦距)、相机外参(旋转平移矩阵),镜头畸变参数
3、用途：畸变矫正、双目视觉、结构光、三维重建，SLAM等
4、世界坐标系：真实世界三维坐标。
5、相机坐标系：世界坐标系在相机内成像，是一个三维坐标系，光心为原点。
6、图像坐标系：二维坐标系，原点为成像平面中点
7、像素坐标系：图像左上角为原点的二维坐标系。
8、光点：光轴与图像平面的交点为主点
9、dx，dy：是相机的固有参数，代表每个像素的毫米数
10、u0，v0：代表像素图像坐标系原点相对像素坐标系原点的偏移量
综上所述，三维到二维的变换就是从世界坐标系到像素坐标系的变换。
世界坐标系---->相机坐标系：刚体变换，也就是旋转平移矩阵
相机坐标系----->图像坐标系：基于小孔成像原理以及相似三角形，这里的变换矩阵参数主要是相机的焦距。
图像坐标系----->像素坐标系：首先这里的目的就是把图像坐标系的点(x,y)---->像素坐标系(u,v)的转换。一开始我想的就是直接把坐标加上那原点的偏移量就好了呀。但是不是这样的。我们可以回忆，在相机坐标系到图像坐标系变换后，图像坐标系的单位是mm，然而像素坐标系的单位是像素pixel。所以这里就需要9，10两个定义。于是他们存在的转换关系就是u=x/dx +u0   v = y/dy +v0。将关系式写成矩阵的形式。
这里将相机坐标系到图像坐标系再到像素坐标这个过程里的两个变换矩阵融合，就得到了相机内参的矩阵。
初次之外，还有就是畸变矫正的问题。镜头畸变分为两种：径向畸变&切向畸变。
11、径向畸变（影响大）：这个是我们需要矫正的，其中又分为桶形畸变和枕形畸变。关于相机径向畸变的数学表达式是：
xy为没有畸变的像素点，Xdis，Ydis是畸变后的位置，k1，k2，k3径向畸变系数，属于摄像头的内参，一般使用前两项，鱼眼相机会使用第三项。
12、切向畸变（影响小）：这个是由于传感器和镜头不平行导致的。
13、平面的单应性关系：从一个平面到另一个平面的映射关系。设成像平面有一个点q(x,y,1)，对应标定板上一点Q(X,Y,Z,1)，对应关系是q=s * H * Q。其中s是尺度因子，H是单应性矩阵(3*3矩阵)---8个自由度，需要8个方程求解，因此需要4个点，4个点的xy对应八个方程。
因此接下来我们就来整理下，这一整个过程需要用到的参数，以及他们是怎么变换的。
@import "tran.png"
假设二维点为(u,v)，对应空间三维点为(X,Y,Z)，然后做增广向量，即m=(x,y,1),M=(X,Y,Z,1)，所以点的投影关系可以表示为：s * m = A [R,T]M。
这里s表示转换尺度因子，可以理解为上图中的Zc，[R,T]就是外参，即旋转平移矩阵。A表示相机的内参
[
    α，γ  ，u0
    0   ，β  ， v0
    0   ，0 ，  1
]
这里u0，v0上面已经解释过了，α和β实际上就是上图等式右边两个矩阵相乘对应位置上的值。而γ：表示两个坐标轴的倾斜角的参数。听说是指像素坐标系两个坐标值可能不垂直？
接下来就进入到标定环节。
因为世界坐标系是我们自己定义的，所以我们可以将标定板平面定义为世界坐标系，垂直于标定板的轴为z轴。那么坐标变换转化为
@import "1.png"
我们这里根据标定板和成像平面的单应性关系：s * m = H * M。这里的H就等于上图中等式最右A * [R,T]。因此我们利用标定板中的多个点求解单应性矩阵。也就是H为(3x3)矩阵，可以写成[h1,h2,h3]那么就可以推出[h1,h2,h3] = λ * A * [R,T]。这里的λ可以理解为转换尺度因子。将上式化简，求出r1,r2,t。
此时又因为相机成像有两个约束条件:1、旋转向量r1,r2分别代表绕x，y轴旋转的量，因此r1，r2是正交的===>r1的转置*r2等于0。2、旋转向量是单位向量，因此r1的模等于r2的模。
利用这两个关系，就可以等到两个方程，我们整理一下现在有的量。
@import "2.png"
1、2两个方程中包含的量有标定板和图像平面之间的单应性关系，还有相机的内参。
此时，需要设计一个中间变量(这个地方很绕，为什么要设计这个中间变量，感觉就好像数学几何体，需要画辅助线解题一样)。中间变量B=A的逆的转置 * A的逆。观察一下，这个中间变量可以将上面的1、2方程中的A全部换下来。同时B是一个对称矩阵，因此它只需要6个参数，即b = [b11,b12,b13,b22,b23,b33]。
此时再将单应性矩阵的列向量进行分解hi = [hi1,hi2,hi3]，带入到方程1中，最终化简等于vij * b，这里的vij很复杂，我没有化简，直接看图待会。同时这个化简结果等于0。同理将其带入到方程2中等到v11的转置 * b=v22的转置 * b，化简一下，就得到了下图的关系式。
@import "3.png"
看到这里，恭喜你，马上就要结束了！
在标定过程中，我们拍摄N张图片，就会得到N个上图第三条的方程，然后就是将N张图片的得到的方程拼起来组成V * b = 0，这里的V是2N*6的矩阵，b有6个参数，只能是6 *1呀。通过该方程求解b中的参数。因为b有6个参数，那么至少需要3个单应性矩阵求解，也就是至少拍3张照片！因为一张照片对应一个单应性矩阵构成上图3的公式，也就对应两个方程！所以需要3张图片。
接下来就是往回求解的过程，还记得当初设置中间变量B，它实际上就是相机内参构成的。然后根据B的值求解相机内参，于是我们就成功获得了A矩阵，接下来再往回，根据一开始说到的单应性矩阵和相机内外参的关系，即[h1,h2,h3] = λ * A * [R,T]，求得旋转平移矩阵。所以整个过程：H--->B--->A--->[R,T]。
接下来就又要普及一个东西了：极大似然估计，源于概率统计，但是这里我们直接看伟人的公式：
@import "4.png"
上面没有说，mij是相机拍摄到的图片对应点的真实坐标。后面那一长条就是利用我们的各种变换计算出真实世界的点投影到图像中的点的坐标。然后最小化其均方误差。这里是不是突然抛出来一个疑问，既然有这个最小化均方误差的方法，为什么不直接迭代，迭代出使误差最小的相机内外参呢(就好像深度学习的loss)？

到这里其实还有一点那就是相机的畸变参数，这里很好理解，直接使用畸变多项式，如下图所示：
@import "5.png"
上面呢，首先是畸变多项式，根据r和xy的关系，转换为图像坐标系，但是图像坐标系还需要转换到像素坐标系。所以那么畸变参数怎么求解呢？首先按照上文，我们先将相机的内外参求解出来，那么u0，v0就是已知的。接下来u冒和v冒是我们在图像中可以观测到的，xy同理？？？--->我认为应该是根据世界坐标系计算得出的xy坐标。那么一个点产生两个方程，那么n张图片每张m个点，就会产生2nm个方程。然后利用最小二乘法求解方程！！！永远学不会的东西：最小二乘法，傅里叶变换、卡尔曼滤波等！！！这里是利用最小二乘法求解方程个数大于未知数个数的解。

于是就出现了完整的极大似然估计，也就是在之前的基础上加上了畸变参数k1，k2。
最后我们来总结一下标定的流程：
### 标定流程 
1、打印标定板
2、从不同角度拍摄标定板
3、检测标定板的特征点--->角点
4、求理想无畸变情况下的内外参
5、利用极大似然估计迭代优化
6、利用最小二乘法求解径向畸变参数
7、综合内外参，畸变参数使用极大似然法，提高估计精度
8、求得相机内外参和畸变系数。


## 启动相机
真正的实践是从这里开始的，在拿到这个海康相机之前，我还有一个相机，它是mightex的，但是有一个很遗憾的事情，那就是我没有在官网找到linux相关的驱动（海康的好像也没找到），但是我在GitHub上找到了驱动，但是这个运行的时候会报错，好像是要一个串口号，但是这个串口号我不知道是哪个。所以哪个相机就到此为止了。
接下来我们说有关这个海康的相机，首先这个相机的官网没有找到linux的驱动，但是在GitHub上是可以找到的，就是能在linux下通过ros进行驱动。然后想一想我好像也没干啥，把包下下来，然后编译，运行就好了。下面是在启动相机时会用到的命令条。
```ruby
cd rpf_workspace/#cd到工作空间
catkin_make#编译
source devel/setup.bash #source一下环境
roslaunch hikrobot_camera hikrobot_camera.launch #运行launch文件，就可以启动相机了
rqt#通过rqt对相机进行可视化
```
## 实践标定
因为在这过程中我还没有了解过GitHub上的标定代码，但是一开始我就知道ros实际上有相机标定的包。
```ruby
sudo apt-get install ros-melodic-camera-calibration#安装标定工具包
roslaunch hikrobot_camera hikrobot_camera.launch #运行launch文件，启动相机
rostopic list#你会需要的
rosrun camera_calibration cameracalibrator.py --size 8x6 --square 0.04 image:=/hikrobot_camera/rgb camera:=/hikrobot_camera
```
--size 记住是内角点个数
--square 单个格子的长度，单位m
image和camera设置摄像头发布的图像话题。
但是好像没那么简单，我感觉我设置对了image和camera，但是还是提示我找不到设备。最后命令行改成
```ruby
rosrun camera_calibration cameracalibrator.py --size 8x6 --square 0.04 image:=/hikrobot_camera/rgb camera:=/hikrobot_camera --no-service-check
```
就可以标定啦！好开心。
然后我们来看一下标定之后的结果！这是我标定打印出的结果，最终保存时，会将标定过程中截取的样本图片和最后数据保存到压缩文件中。
```ruby
*** Added sample 1, p_x = 0.357, p_y = 0.879, p_size = 0.371, skew = 0.014
......
*** Added sample 159, p_x = 0.707, p_y = 0.481, p_size = 0.610, skew = 0.119
**** Calibrating ****
mono pinhole calibration...
D = [-0.1267947735558876, 0.1670237702731591, 0.00037754570888461737, -0.00019124719591641137, 0.0]
K = [1060.7324422191996, 0.0, 652.8022630413026, 0.0, 1059.7687626765291, 522.92711181692, 0.0, 0.0, 1.0]
R = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0]
P = [1045.5968017578125, 0.0, 651.8204060369899, 0.0, 0.0, 1045.533935546875, 522.9432049971656, 0.0, 0.0, 0.0, 1.0, 0.0]
None
# oST version 5.0 parameters
[image]#图像宽度和高度
width
1280
height
1024
[narrow_stereo]#相机名字
camera matrix#相机内部参数矩阵
1060.732442 0.000000 652.802263
0.000000 1059.768763 522.927112
0.000000 0.000000 1.000000
distortion#畸变模型系数
-0.126795 0.167024 0.000378 -0.000191 0.000000
rectification#矫正矩阵一般为单位矩阵
1.000000 0.000000 0.000000
0.000000 1.000000 0.000000
0.000000 0.000000 1.000000
projection#世界坐标系到相机坐标系转换的[R,T]矩阵
1045.596802 0.000000 651.820406 0.000000
0.000000 1045.533936 522.943205 0.000000
0.000000 0.000000 1.000000 0.000000
```
## 使用标定数据
我想想要了解这一部分，首先第一步是我们需要看下相机启动的代码。这一部分很难！因为我看Python代码多一点，c++代码基本就没看过。
首先我们来了解一下相机启动的launch文件。
```ruby
<launch>
    <rosparam file="$(find hikrobot_camera)/config/camera-indoor.yaml" command="load"/>
    <node pkg="hikrobot_camera" type="hikrobot_camera" name="hikrobot_camera" respawn="true" output="screen" /> 
    <!-- 
    pkg指出ROS应该运行哪个pkg
    type是可执行文件的名称
    name则是可以任意给出的，它覆盖了原文件中ros::init指定的node的名字 -->
</launch>
```
首先我们要清楚，ros中的launch文件实际上是使用xml格式书写的。launch文件就是启动节点嘛，所以如果是添加标定文件，肯定就是在这里launch文件中添加即可。
接下来，我们就来简单了解一下launch文件，只针对上面这个launch文件，就是我在修改launch文件学到的东西。首先在launch文件包含很多标签，共有11种
```ruby
<launch>,<node>,<machine>,<include>,<remap>,<env>,<param>,<rosparam>,<group>,<test>,<arg>
```
其中在这个launch文件中使用了三个，其中还要再加一个。
### <launch>
该标签是任何roslaunch文件的根元素。其唯一目的是充当其他元素的容器
### <node>
最常见的标签，也就是在launch文件中负责启动和关闭节点。什么是节点，这个可以去学习一下ros相关的东西。这里需要注意一个问题，那就是一个launch文件可以包含多个ros节点，但是启动多个节点时不能保证启动的先后顺序。我的理解就是所有的节点都是具备自己启动的能力的。
在这个node中有一些参数需要加载，其中包括下面这些：
```ruby
pkg=''#这里是节点包
type =''#节点类型
name = ''#节点名称 
args = ''#将参数传递给节点
machine = ''#指定机器上的启动节点
respawn = ''#如果退出，则自动重新启动该节点
```
### <rosparam>
该标签允许使用rosparam yaml文件从ros参数服务器加载和转储参数。它可以用来删除参数，可以将标记放在标记内，在这种情况下，该参数被视为私有名称。其中包括
```ruby
command = ''#可选load，dump，delete。默认是load
file = ''#这里放的是rosparam文件的名称------格式应该是file="$(find pkg-name)/config/camera-indoor.yaml"
param = ''#这里是参数名称
```
不知道大家在看这个代码的时，对这个东西好不好奇---->$(find hikrobot_camera)。这是个什么东西？在看了上面之后，大概明白了，也就是我们rosparam是用来加载参数的，这个参数主要是节点开始运行的参数。我们可以理解问节点的标签完成的是Python的调用，那么这个参数加载实际上就是init初始化。所以在加载参数时，需要指定功能包，但是这里指定功能包最多也就是返回功能包的地址吧。
阿这。。。。我去做了一件事，我将$(find hikrobot_camera)替换成了我电脑的地址。。。launch文件运行成功了。怎么说呢，我现在也迷茫了，但是我们可以确定那就是确实返回的是地址，但是它是怎么对应的pkg呢？以后在说吧
### 添加param
现在我们就可以将标定好的参数通过launch文件添加到节点的运行中加载。看这句话，，就知道这个参数的添加一定是在node的下一级别的。最终修改好的launch文件是这样的：
```ruby
<launch>
    <rosparam file="/home/ktd/rpf_workspace/src/HIKROBOT-MVS-CAMERA-ROS/config/camera-indoor.yaml" command="load"/>
    <node pkg="hikrobot_camera" type="hikrobot_camera" name="hikrobot_camera" respawn="true" output="screen" >
            <param name="camera_info_url" type="string" value="file:///home/ktd/rpf_workspace/src/HIKROBOT-MVS-CAMERA-ROS/calibrationdata/ost.yaml" />
    </node>
    <!--
    pkg指出ROS应该运行哪个pkg
    type是可执行文件的名称
    name则是可以任意给出的，它覆盖了原文件中ros::init指定的node的名字 -->
</launch>
```
这里还需要注意一点，那就是每个标签都有结束的标志，这也就是为什么标签后面都有"/"。最后就是保存launch文件，然后运行相机即可。
